type Pair @entity {
  id: ID!
  token1: Token!
  token2: Token!
  address: String!
  price: Int!
  buys: [Buy!]!
  asks: [Ask!]!
}

type Buy @entity {
  id: ID!
  price: Int!
  quantity: Int!
  sender: String!
}

type Ask @entity {
  id: ID!
  price: Int!
  quantity: Int!
  sender: String!
  # Probably needs to specify what tokens were involved
}

# TODO: The difference between a queued bid/ask and a finished purchase is confusing
# You should add a completed: Boolean! field to Buy/Ask and generally clear this up.

type Swap @entity {
  id: ID! # This particular id is the appended token1 ID and token2 ID. This will always be unique and is useful for querying.
  token1Sender: String!
  token2Sender: String!
  token1Price: Int!
  token2Price: Int!
  spread: Int!
  quantity: Int!
  # TODO addresses are more efficiently encoded as Bytes
}

type DirectPurchase @entity {
  id: ID!
  exchange: String!
  sender: String!
  isToken1: Boolean!
  price: Int!
  quantity: Int!
}

type Token @entity {
  id: ID!
  address: String!
  name: String!
  symbol: String!
  pairs1: [Pair!]! # Pairs where this is token1- I"M TRYING NOT TO USE THESE, THEY SEEM LIKE A CRUTCH
  pairs2: [Pair!]!
}

# union Order = Buy | Ask

type User @entity {
  id: ID!
  address: String!
  asks: [Ask!]!
  buys: [Buy!]!
}
